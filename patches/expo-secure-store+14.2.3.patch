diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
index 62a9908..8411e7e 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
@@ -2,6 +2,7 @@ package expo.modules.securestore
 
 import android.annotation.SuppressLint
 import android.app.Activity
+import android.app.KeyguardManager
 import android.content.Context
 import android.os.Build
 import androidx.biometric.BiometricManager
@@ -19,17 +20,23 @@ class AuthenticationHelper(
 ) {
   private var isAuthenticating = false
 
-  suspend fun authenticateCipher(cipher: Cipher, requiresAuthentication: Boolean, title: String): Cipher {
-    if (requiresAuthentication) {
-      return openAuthenticationPrompt(cipher, title).cryptoObject?.cipher
-        ?: throw AuthenticationException("Couldn't get cipher from authentication result")
-    }
-    return cipher
+  suspend fun authenticateCipher(
+    cipher: Cipher,
+    title: String,
+    enableCredentialsAlternative: Boolean
+  ): BiometricPrompt.AuthenticationResult {
+
+    val promptResult = openAuthenticationPrompt(cipher, title, enableCredentialsAlternative)
+    promptResult.cryptoObject?.cipher
+      ?: throw AuthenticationException("Couldn't get cipher from authentication result")
+
+    return promptResult
   }
 
   private suspend fun openAuthenticationPrompt(
     cipher: Cipher,
-    title: String
+    title: String,
+    enableCredentialsAlternative: Boolean
   ): BiometricPrompt.AuthenticationResult {
     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
       throw AuthenticationException("Biometric authentication requires Android API 23")
@@ -40,11 +47,17 @@ class AuthenticationHelper(
 
     isAuthenticating = true
 
-    assertBiometricsSupport()
+    if (enableCredentialsAlternative) {
+      assertDeviceSecurity()
+    } else {
+      assertBiometricsSupport()
+    }
+
     val fragmentActivity = getCurrentActivity() as? FragmentActivity
       ?: throw AuthenticationException("Cannot display biometric prompt when the app is not in the foreground")
 
-    val authenticationPrompt = AuthenticationPrompt(fragmentActivity, context, title)
+    val authenticationPrompt =
+      AuthenticationPrompt(fragmentActivity, context, title, enableCredentialsAlternative)
 
     return withContext(Dispatchers.Main.immediate) {
       try {
@@ -56,6 +69,14 @@ class AuthenticationHelper(
     }
   }
 
+  fun assertDeviceSecurity() {
+    val manager = context.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
+    val isSecure = manager.isDeviceSecure
+    if (!isSecure) {
+      throw AuthenticationException("No authentication method available")
+    }
+  }
+
   fun assertBiometricsSupport() {
     val biometricManager = BiometricManager.from(context)
     @SuppressLint("SwitchIntDef") // BiometricManager.BIOMETRIC_SUCCESS shouldn't do anything
@@ -63,15 +84,19 @@ class AuthenticationHelper(
       BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE, BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> {
         throw AuthenticationException("No hardware available for biometric authentication. Use expo-local-authentication to check if the device supports it")
       }
+
       BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> {
         throw AuthenticationException("No biometrics are currently enrolled")
       }
+
       BiometricManager.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED -> {
         throw AuthenticationException("An update is required before the biometrics can be used")
       }
+
       BiometricManager.BIOMETRIC_ERROR_UNSUPPORTED -> {
         throw AuthenticationException("Biometric authentication is unsupported")
       }
+
       BiometricManager.BIOMETRIC_STATUS_UNKNOWN -> {
         throw AuthenticationException("Biometric authentication status is unknown")
       }
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationPrompt.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationPrompt.kt
index e5729cc..ad547d0 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationPrompt.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationPrompt.kt
@@ -1,5 +1,7 @@
 package expo.modules.securestore
 
+import androidx.biometric.BiometricManager.Authenticators.BIOMETRIC_STRONG
+import androidx.biometric.BiometricManager.Authenticators.DEVICE_CREDENTIAL
 import android.content.Context
 import androidx.biometric.BiometricPrompt
 import androidx.biometric.BiometricPrompt.PromptInfo
@@ -11,11 +13,18 @@ import kotlin.coroutines.resume
 import kotlin.coroutines.resumeWithException
 import kotlin.coroutines.suspendCoroutine
 
-class AuthenticationPrompt(private val currentActivity: FragmentActivity, context: Context, title: String) {
+class AuthenticationPrompt(
+  private val currentActivity: FragmentActivity,
+  context: Context,
+  title: String,
+  enableCredentialsAlternative: Boolean
+) {
+  private var authType: Int =
+    if (enableCredentialsAlternative) BIOMETRIC_STRONG or DEVICE_CREDENTIAL else BIOMETRIC_STRONG
   private var executor: Executor = ContextCompat.getMainExecutor(context)
   private var promptInfo = PromptInfo.Builder()
     .setTitle(title)
-    .setNegativeButtonText(context.getString(android.R.string.cancel))
+    .setAllowedAuthenticators(authType)
     .build()
 
   suspend fun authenticate(cipher: Cipher): BiometricPrompt.AuthenticationResult? =
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
index 0fef884..35742e7 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
@@ -5,6 +5,7 @@ import android.content.SharedPreferences
 import android.preference.PreferenceManager
 import android.security.keystore.KeyPermanentlyInvalidatedException
 import android.util.Log
+import androidx.biometric.BiometricPrompt
 import expo.modules.kotlin.exception.CodedException
 import expo.modules.kotlin.exception.Exceptions
 import expo.modules.kotlin.functions.Coroutine
@@ -76,7 +77,8 @@ open class SecureStoreModule : Module() {
     }
 
     OnCreate {
-      authenticationHelper = AuthenticationHelper(reactContext, appContext.legacyModuleRegistry)
+      authenticationHelper =
+        AuthenticationHelper(reactContext, appContext.legacyModuleRegistry)
       hybridAESEncryptor = HybridAESEncryptor(reactContext, mAESEncryptor)
 
       val keyStore = KeyStore.getInstance(KEYSTORE_PROVIDER)
@@ -85,20 +87,24 @@ open class SecureStoreModule : Module() {
     }
   }
 
-  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): String? {
+  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): Pair<String?, Int> {
     // We use a SecureStore-specific shared preferences file, which lets us do things like enumerate
     // its entries or clear all of them
     val prefs: SharedPreferences = getSharedPreferences()
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
     if (prefs.contains(keychainAwareKey)) {
-      return readJSONEncodedItem(key, prefs, options)
+      val result = readJSONEncodedItem(key, prefs, options)
+      return Pair(result.first, result.second?.authenticationType ?: 0)
     } else if (prefs.contains(key)) { // For backwards-compatibility try to read using the old key format
-      return readJSONEncodedItem(key, prefs, options)
+      val result = readJSONEncodedItem(key, prefs, options)
+      return Pair(result.first, result.second?.authenticationType ?: 0)
     }
-    return null
+    return Pair(null, 0)
   }
 
-  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): String? {
+  private suspend fun readJSONEncodedItem(
+    key: String, prefs: SharedPreferences, options: SecureStoreOptions
+  ): Pair<String?, BiometricPrompt.AuthenticationResult?> {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
 
     val legacyEncryptedItemString = prefs.getString(key, null)
@@ -108,64 +114,92 @@ open class SecureStoreModule : Module() {
     // It's not possible to efficiently remove all values from older versions of secure-store when an invalidated keychain is deleted.
     // In some edge cases it will lead to read errors until the value is removed from the shared preferences
     val legacyReadFailedWarning = if (currentEncryptedItemString == null) {
-      ". This exception occurred when trying to read a value saved with an " +
-        "older version of `expo-secure-store`. It usually means that the keychain you provided is incorrect, " +
-        "but it might be raised because the keychain used to decrypt this key has been invalidated and deleted." +
-        " If you are confident that the keychain you provided is correct and want to avoid this error in the " +
-        "future you should save a new value under this key or use `deleteItemImpl()` and remove the existing one."
+      ". This exception occurred when trying to read a value saved with an " + "older version of `expo-secure-store`. It usually means that the keychain you provided is incorrect, " + "but it might be raised because the keychain used to decrypt this key has been invalidated and deleted." + " If you are confident that the keychain you provided is correct and want to avoid this error in the " + "future you should save a new value under this key or use `deleteItemImpl()` and remove the existing one."
     } else {
       ""
     }
 
-    encryptedItemString ?: return null
+    encryptedItemString ?: return Pair(null, null)
 
     val encryptedItem: JSONObject = try {
       JSONObject(encryptedItemString)
     } catch (e: JSONException) {
-      throw DecryptException("Could not parse the encrypted JSON item in SecureStore: ${e.message}", key, options.keychainService, e)
+      throw DecryptException(
+        "Could not parse the encrypted JSON item in SecureStore: ${e.message}",
+        key,
+        options.keychainService,
+        e
+      )
     }
 
     val scheme = encryptedItem.optString(SCHEME_PROPERTY).takeIf { it.isNotEmpty() }
-      ?: throw DecryptException("Could not find the encryption scheme used for key: $key", key, options.keychainService)
-    val requireAuthentication = encryptedItem.optBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false)
+      ?: throw DecryptException(
+        "Could not find the encryption scheme used for key: $key",
+        key,
+        options.keychainService
+      )
+    val requireAuthentication =
+      encryptedItem.optBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false)
     val usesKeystoreSuffix = encryptedItem.optBoolean(USES_KEYSTORE_SUFFIX_PROPERTY, false)
 
     try {
       when (scheme) {
         AESEncryptor.NAME -> {
-          val secretKeyEntry = getKeyEntryCompat(SecretKeyEntry::class.java, mAESEncryptor, options, requireAuthentication, usesKeystoreSuffix) ?: run {
+          val secretKeyEntry = getKeyEntryCompat(
+            SecretKeyEntry::class.java,
+            mAESEncryptor,
+            options,
+            requireAuthentication,
+            usesKeystoreSuffix
+          ) ?: run {
             Log.w(
               TAG,
-              "An entry was found for key $key under keychain ${options.keychainService}, but there is no corresponding KeyStore key. " +
-                "This situation occurs when the app is reinstalled. The value will be removed to avoid future errors. Returning null"
+              "An entry was found for key $key under keychain ${options.keychainService}, but there is no corresponding KeyStore key. " + "This situation occurs when the app is reinstalled. The value will be removed to avoid future errors. Returning null"
             )
             deleteItemImpl(key, options)
-            return null
+            return Pair(null, null)
           }
-          return mAESEncryptor.decryptItem(key, encryptedItem, secretKeyEntry, options, authenticationHelper)
+          val decryptResult = mAESEncryptor.decryptItem(
+            key, encryptedItem, secretKeyEntry, options, authenticationHelper
+          )
+          return decryptResult
         }
+
         HybridAESEncryptor.NAME -> {
-          val privateKeyEntry = getKeyEntryCompat(PrivateKeyEntry::class.java, hybridAESEncryptor, options, requireAuthentication, usesKeystoreSuffix)
-            ?: return null
-          return hybridAESEncryptor.decryptItem(key, encryptedItem, privateKeyEntry, options, authenticationHelper)
+          val privateKeyEntry = getKeyEntryCompat(
+            PrivateKeyEntry::class.java,
+            hybridAESEncryptor,
+            options,
+            requireAuthentication,
+            usesKeystoreSuffix
+          ) ?: return Pair(null, null)
+
+          val decryptResult = hybridAESEncryptor.decryptItem(
+            key, encryptedItem, privateKeyEntry, options, authenticationHelper
+          )
+          return decryptResult
         }
+
         else -> {
-          throw DecryptException("The item for key $key in SecureStore has an unknown encoding scheme $scheme)", key, options.keychainService)
+          throw DecryptException(
+            "The item for key $key in SecureStore has an unknown encoding scheme $scheme)",
+            key,
+            options.keychainService
+          )
         }
       }
     } catch (e: KeyPermanentlyInvalidatedException) {
       Log.w(TAG, "The requested key has been permanently invalidated. Returning null")
-      return null
+      return Pair(null, null)
     } catch (e: BadPaddingException) {
       // The key from the KeyStore is unable to decode the entry. This is because a new key was generated, but the entries are encrypted using the old one.
       // This usually means that the user has reinstalled the app. We can safely remove the old value and return null as it's impossible to decrypt it.
       Log.w(
         TAG,
-        "Failed to decrypt the entry for $key under keychain ${options.keychainService}. " +
-          "The entry in shared preferences is out of sync with the keystore. It will be removed, returning null."
+        "Failed to decrypt the entry for $key under keychain ${options.keychainService}. " + "The entry in shared preferences is out of sync with the keystore. It will be removed, returning null."
       )
       deleteItemImpl(key, options)
-      return null
+      return Pair(null, null)
     } catch (e: GeneralSecurityException) {
       throw (DecryptException(e.message, key, options.keychainService, e))
     } catch (e: CodedException) {
@@ -175,23 +209,32 @@ open class SecureStoreModule : Module() {
     }
   }
 
-  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean) {
+  private suspend fun setItemImpl(
+    key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean
+  ): Int {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
     val prefs: SharedPreferences = getSharedPreferences()
 
     if (value == null) {
       val success = prefs.edit().putString(keychainAwareKey, null).commit()
       if (!success) {
-        throw WriteException("Could not write a null value to SecureStore", key, options.keychainService)
+        throw WriteException(
+          "Could not write a null value to SecureStore", key, options.keychainService
+        )
       }
-      return
+      return 0
+    }
+
+    if (prefs.contains(keychainAwareKey) && options.failOnDuplicate) {
+      throw WriteException("Key already exists", key, options.keychainService)
     }
 
     try {
       if (keyIsInvalidated) {
         // Invalidated keys will block writing even though it's not possible to re-validate them
         // so we remove them before saving.
-        val alias = mAESEncryptor.getExtendedKeyStoreAlias(options, options.requireAuthentication)
+        val alias =
+          mAESEncryptor.getExtendedKeyStoreAlias(options, options.requireAuthentication)
         removeKeyFromKeystore(alias, options.keychainService)
       }
 
@@ -200,21 +243,45 @@ open class SecureStoreModule : Module() {
        use in the encrypted JSON item so that we know how to decode and decrypt it when reading
        back a value.
        */
-      val secretKeyEntry: SecretKeyEntry = getOrCreateKeyEntry(SecretKeyEntry::class.java, mAESEncryptor, options, options.requireAuthentication)
-      val encryptedItem = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper)
+      val secretKeyEntry: SecretKeyEntry = getOrCreateKeyEntry(
+        SecretKeyEntry::class.java, mAESEncryptor, options, options.requireAuthentication
+      )
+      val encryptResult = mAESEncryptor.createEncryptedItem(
+        value,
+        secretKeyEntry,
+        options.requireAuthentication,
+        options.authenticationPrompt,
+        authenticationHelper,
+        options.enableCredentialsAlternative
+      )
+      val encryptedItem = encryptResult.first
       encryptedItem.put(SCHEME_PROPERTY, AESEncryptor.NAME)
-      saveEncryptedItem(encryptedItem, prefs, keychainAwareKey, options.requireAuthentication, options.keychainService)
+      saveEncryptedItem(
+        encryptedItem,
+        prefs,
+        keychainAwareKey,
+        options.requireAuthentication,
+        options.keychainService
+      )
 
       // If a legacy value exists under this key we remove it to avoid unexpected errors in the future
       if (prefs.contains(key)) {
         prefs.edit().remove(key).apply()
       }
+
+      return encryptResult.second?.authenticationType ?: 0
+
     } catch (e: KeyPermanentlyInvalidatedException) {
       if (!keyIsInvalidated) {
         Log.w(TAG, "Key has been invalidated, retrying with the key deleted")
         return setItemImpl(key, value, options, true)
       }
-      throw EncryptException("Encryption Failed. The key $key has been permanently invalidated and cannot be reinitialized", key, options.keychainService, e)
+      throw EncryptException(
+        "Encryption Failed. The key $key has been permanently invalidated and cannot be reinitialized",
+        key,
+        options.keychainService,
+        e
+      )
     } catch (e: GeneralSecurityException) {
       throw EncryptException(e.message, key, options.keychainService, e)
     } catch (e: CodedException) {
@@ -224,17 +291,29 @@ open class SecureStoreModule : Module() {
     }
   }
 
-  private fun saveEncryptedItem(encryptedItem: JSONObject, prefs: SharedPreferences, key: String, requireAuthentication: Boolean, keychainService: String): Boolean {
+  private fun saveEncryptedItem(
+    encryptedItem: JSONObject,
+    prefs: SharedPreferences,
+    key: String,
+    requireAuthentication: Boolean,
+    keychainService: String
+  ): Boolean {
     // We need a way to recognize entries that have been saved under an alias created with getExtendedKeychain
     encryptedItem.put(USES_KEYSTORE_SUFFIX_PROPERTY, true)
     // In order to be able to have the same keys under different keychains
     // we need a way to recognize what is the keychain of the item when we read it
     encryptedItem.put(KEYSTORE_ALIAS_PROPERTY, keychainService)
-    encryptedItem.put(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, requireAuthentication)
+    encryptedItem.put(
+      AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, requireAuthentication
+    )
 
     val encryptedItemString = encryptedItem.toString()
     if (encryptedItemString.isNullOrEmpty()) { // JSONObject#toString() may return null
-      throw WriteException("Could not JSON-encode the encrypted item for SecureStore - the string $encryptedItemString is null or empty", key, keychainService)
+      throw WriteException(
+        "Could not JSON-encode the encrypted item for SecureStore - the string $encryptedItemString is null or empty",
+        key,
+        keychainService
+      )
     }
 
     return prefs.edit().putString(key, encryptedItemString).commit()
@@ -259,7 +338,9 @@ open class SecureStoreModule : Module() {
     }
 
     if (!success) {
-      throw DeleteException("Could not delete the item from SecureStore", key, options.keychainService)
+      throw DeleteException(
+        "Could not delete the item from SecureStore", key, options.keychainService
+      )
     }
   }
 
@@ -282,7 +363,8 @@ open class SecureStoreModule : Module() {
       }
 
       val entryKeychainService = jsonEntry.optString(KEYSTORE_ALIAS_PROPERTY) ?: continue
-      val requireAuthentication = jsonEntry.optBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false)
+      val requireAuthentication =
+        jsonEntry.optBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY, false)
 
       // Entries which don't require authentication use separate keychains which can't be invalidated,
       // so we shouldn't delete them.
@@ -299,9 +381,7 @@ open class SecureStoreModule : Module() {
    * Because of that we need to check if there are any keys stored with the old secure-store key format.
    */
   private fun <E : KeyStore.Entry> getLegacyKeyEntry(
-    keyStoreEntryClass: Class<E>,
-    encryptor: KeyBasedEncryptor<E>,
-    options: SecureStoreOptions
+    keyStoreEntryClass: Class<E>, encryptor: KeyBasedEncryptor<E>, options: SecureStoreOptions
   ): E? {
     val keystoreAlias = encryptor.getKeyStoreAlias(options)
     if (!keyStore.containsAlias(encryptor.getKeyStoreAlias(options))) {
@@ -343,7 +423,11 @@ open class SecureStoreModule : Module() {
     return getKeyEntry(keyStoreEntryClass, encryptor, options, requireAuthentication) ?: run {
       // Android won't allow us to generate the keys if the device doesn't support biometrics or no biometrics are enrolled
       if (requireAuthentication) {
-        authenticationHelper.assertBiometricsSupport()
+        if (options.enableCredentialsAlternative) {
+          authenticationHelper.assertDeviceSecurity()
+        } else {
+          authenticationHelper.assertBiometricsSupport()
+        }
       }
       encryptor.initializeKeyStoreEntry(keyStore, options)
     }
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
index 79a600f..df1cfe3 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
@@ -8,5 +8,7 @@ class SecureStoreOptions(
   // Prompt can't be an empty string
   @Field var authenticationPrompt: String = " ",
   @Field var keychainService: String = SecureStoreModule.DEFAULT_KEYSTORE_ALIAS,
-  @Field var requireAuthentication: Boolean = false
+  @Field var requireAuthentication: Boolean = false,
+  @Field var failOnDuplicate: Boolean = false,
+  @Field var enableCredentialsAlternative: Boolean = false,
 ) : Record, Serializable
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
index 3a12dc9..2df4b20 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
@@ -1,9 +1,12 @@
 package expo.modules.securestore.encryptors
 
 import android.annotation.TargetApi
+import android.os.Build
 import android.security.keystore.KeyGenParameterSpec
 import android.security.keystore.KeyProperties
 import android.util.Base64
+import androidx.annotation.RequiresApi
+import androidx.biometric.BiometricPrompt
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.DecryptException
 import expo.modules.securestore.SecureStoreModule
@@ -40,7 +43,9 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
    * Two key store entries exist for every `keychainService` passed from the JS side. This is
    * because it's not possible to store unauthenticated data in authenticated key stores.
    */
-  override fun getExtendedKeyStoreAlias(options: SecureStoreOptions, requireAuthentication: Boolean): String {
+  override fun getExtendedKeyStoreAlias(
+    options: SecureStoreOptions, requireAuthentication: Boolean
+  ): String {
     // We aren't using requiresAuthentication from the options, because it's not a necessary option for read requests
     val suffix = if (requireAuthentication) {
       SecureStoreModule.AUTHENTICATED_KEYSTORE_SUFFIX
@@ -50,20 +55,31 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     return "${getKeyStoreAlias(options)}:$suffix"
   }
 
+  @RequiresApi(Build.VERSION_CODES.R)
   @TargetApi(23)
   @Throws(GeneralSecurityException::class)
-  override fun initializeKeyStoreEntry(keyStore: KeyStore, options: SecureStoreOptions): KeyStore.SecretKeyEntry {
+  override fun initializeKeyStoreEntry(
+    keyStore: KeyStore, options: SecureStoreOptions
+  ): KeyStore.SecretKeyEntry {
     val extendedKeystoreAlias = getExtendedKeyStoreAlias(options, options.requireAuthentication)
     val keyPurposes = KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
 
-    val algorithmSpec: AlgorithmParameterSpec = KeyGenParameterSpec.Builder(extendedKeystoreAlias, keyPurposes)
-      .setKeySize(AES_KEY_SIZE_BITS)
-      .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
-      .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
-      .setUserAuthenticationRequired(options.requireAuthentication)
-      .build()
+    val authType =
+      if (options.enableCredentialsAlternative) KeyProperties.AUTH_BIOMETRIC_STRONG or KeyProperties.AUTH_DEVICE_CREDENTIAL
+      else KeyProperties.AUTH_BIOMETRIC_STRONG
+
+    val algorithmSpec: AlgorithmParameterSpec =
+      KeyGenParameterSpec.Builder(extendedKeystoreAlias, keyPurposes)
+        .setKeySize(AES_KEY_SIZE_BITS).setBlockModes(KeyProperties.BLOCK_MODE_GCM)
+        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
+        .setUserAuthenticationRequired(options.requireAuthentication)
+        .setUserAuthenticationParameters(
+          0,
+          authType,
+        ).build()
 
-    val keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, keyStore.provider)
+    val keyGenerator =
+      KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, keyStore.provider)
     keyGenerator.init(algorithmSpec)
 
     // KeyGenParameterSpec stores the key when it is generated
@@ -78,22 +94,36 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     keyStoreEntry: KeyStore.SecretKeyEntry,
     requireAuthentication: Boolean,
     authenticationPrompt: String,
-    authenticationHelper: AuthenticationHelper
-  ): JSONObject {
+    authenticationHelper: AuthenticationHelper,
+    enableCredentialsAlternative: Boolean,
+  ): Pair<JSONObject, BiometricPrompt.AuthenticationResult?> {
     val secretKey = keyStoreEntry.secretKey
     val cipher = Cipher.getInstance(AES_CIPHER)
     cipher.init(Cipher.ENCRYPT_MODE, secretKey)
 
     val gcmSpec = cipher.parameters.getParameterSpec(GCMParameterSpec::class.java)
-    val authenticatedCipher = authenticationHelper.authenticateCipher(cipher, requireAuthentication, authenticationPrompt)
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val authenticatedCipher: Cipher
+
+    if (requireAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(
+        cipher,
+        authenticationPrompt,
+        enableCredentialsAlternative
+      )
+      authenticatedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      authenticatedCipher = cipher
+    }
 
-    return createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec)
+    return Pair(
+      createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec),
+      promptResult
+    )
   }
 
   internal fun createEncryptedItemWithCipher(
-    plaintextValue: String,
-    cipher: Cipher,
-    gcmSpec: GCMParameterSpec
+    plaintextValue: String, cipher: Cipher, gcmSpec: GCMParameterSpec
   ): JSONObject {
     val plaintextBytes = plaintextValue.toByteArray(StandardCharsets.UTF_8)
     val ciphertextBytes = cipher.doFinal(plaintextBytes)
@@ -101,9 +131,7 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     val ivString = Base64.encodeToString(gcmSpec.iv, Base64.NO_WRAP)
     val authenticationTagLength = gcmSpec.tLen
 
-    return JSONObject()
-      .put(CIPHERTEXT_PROPERTY, ciphertext)
-      .put(IV_PROPERTY, ivString)
+    return JSONObject().put(CIPHERTEXT_PROPERTY, ciphertext).put(IV_PROPERTY, ivString)
       .put(GCM_AUTHENTICATION_TAG_LENGTH_PROPERTY, authenticationTagLength)
   }
 
@@ -114,7 +142,7 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     keyStoreEntry: KeyStore.SecretKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): Pair<String, BiometricPrompt.AuthenticationResult?> {
     val ciphertext = encryptedItem.getString(CIPHERTEXT_PROPERTY)
     val ivString = encryptedItem.getString(IV_PROPERTY)
     val authenticationTagLength = encryptedItem.getInt(GCM_AUTHENTICATION_TAG_LENGTH_PROPERTY)
@@ -122,14 +150,36 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     val ivBytes = Base64.decode(ivString, Base64.DEFAULT)
     val gcmSpec = GCMParameterSpec(authenticationTagLength, ivBytes)
     val cipher = Cipher.getInstance(AES_CIPHER)
-    val requiresAuthentication = encryptedItem.optBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY)
+    val requiresAuthentication =
+      encryptedItem.optBoolean(AuthenticationHelper.REQUIRE_AUTHENTICATION_PROPERTY)
 
     if (authenticationTagLength < MIN_GCM_AUTHENTICATION_TAG_LENGTH) {
-      throw DecryptException("Authentication tag length must be at least $MIN_GCM_AUTHENTICATION_TAG_LENGTH bits long", key, options.keychainService)
+      throw DecryptException(
+        "Authentication tag length must be at least $MIN_GCM_AUTHENTICATION_TAG_LENGTH bits long",
+        key,
+        options.keychainService
+      )
     }
     cipher.init(Cipher.DECRYPT_MODE, keyStoreEntry.secretKey, gcmSpec)
-    val unlockedCipher = authenticationHelper.authenticateCipher(cipher, requiresAuthentication, options.authenticationPrompt)
-    return String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8)
+
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val unlockedCipher: Cipher
+
+    if (requiresAuthentication) {
+      promptResult =
+        authenticationHelper.authenticateCipher(
+          cipher,
+          options.authenticationPrompt,
+          options.enableCredentialsAlternative
+        )
+      unlockedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      unlockedCipher = cipher
+    }
+
+    return Pair(
+      String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8), promptResult
+    )
   }
 
   companion object {
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
index fb42599..ad23452 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
@@ -4,6 +4,7 @@ import android.annotation.SuppressLint
 import android.content.Context
 import android.security.keystore.KeyProperties
 import android.util.Base64
+import androidx.biometric.BiometricPrompt
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.EncryptException
 import expo.modules.securestore.KeyStoreException
@@ -38,14 +39,22 @@ import javax.crypto.spec.SecretKeySpec
  * When we drop support for Android API 22, we can remove the write paths but need to keep the
  * read paths for phones that still have hybrid-encrypted values on disk.
  */
-class HybridAESEncryptor(private var mContext: Context, private val mAESEncryptor: AESEncryptor) : KeyBasedEncryptor<KeyStore.PrivateKeyEntry> {
+class HybridAESEncryptor(
+  private var mContext: Context,
+  private val mAESEncryptor: AESEncryptor,
+) : KeyBasedEncryptor<KeyStore.PrivateKeyEntry> {
   private val mSecureRandom: SecureRandom = SecureRandom()
-  override fun getExtendedKeyStoreAlias(options: SecureStoreOptions, requireAuthentication: Boolean): String {
-    val suffix = if (requireAuthentication) {
-      SecureStoreModule.AUTHENTICATED_KEYSTORE_SUFFIX
-    } else {
-      SecureStoreModule.UNAUTHENTICATED_KEYSTORE_SUFFIX
-    }
+
+  override fun getExtendedKeyStoreAlias(
+    options: SecureStoreOptions,
+    requireAuthentication: Boolean,
+  ): String {
+    val suffix =
+      if (requireAuthentication) {
+        SecureStoreModule.AUTHENTICATED_KEYSTORE_SUFFIX
+      } else {
+        SecureStoreModule.UNAUTHENTICATED_KEYSTORE_SUFFIX
+      }
     return "${getKeyStoreAlias(options)}:$suffix"
   }
 
@@ -55,11 +64,14 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
   }
 
   @Throws(GeneralSecurityException::class)
-  override fun initializeKeyStoreEntry(keyStore: KeyStore, options: SecureStoreOptions): KeyStore.PrivateKeyEntry {
+  override fun initializeKeyStoreEntry(
+    keyStore: KeyStore,
+    options: SecureStoreOptions,
+  ): KeyStore.PrivateKeyEntry {
     // This should never be called after we dropped Android SDK 22 support.
     throw KeyStoreException(
       "Tried to initialize HybridAESEncryptor key store entry on Android SDK >= 23. This shouldn't happen. " +
-        "If you see this message report an issue at https://github.com/expo/expo."
+          "If you see this message report an issue at https://github.com/expo/expo.",
     )
   }
 
@@ -69,14 +81,15 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     keyStoreEntry: KeyStore.PrivateKeyEntry,
     requireAuthentication: Boolean,
     authenticationPrompt: String,
-    authenticationHelper: AuthenticationHelper
-  ): JSONObject {
+    authenticationHelper: AuthenticationHelper,
+    enableCredentialsAlternative: Boolean,
+  ): Pair<JSONObject, BiometricPrompt.AuthenticationResult?> {
     // This should never be called after we dropped Android SDK 22 support.
     throw EncryptException(
       "HybridAESEncryption should not be used on Android SDK >= 23. This shouldn't happen. " +
-        "If you see this message report an issue at https://github.com/expo/expo.",
+          "If you see this message report an issue at https://github.com/expo/expo.",
+      "unknown",
       "unknown",
-      "unknown"
     )
   }
 
@@ -86,8 +99,8 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     encryptedItem: JSONObject,
     keyStoreEntry: KeyStore.PrivateKeyEntry,
     options: SecureStoreOptions,
-    authenticationHelper: AuthenticationHelper
-  ): String {
+    authenticationHelper: AuthenticationHelper,
+  ): Pair<String, BiometricPrompt.AuthenticationResult?> {
     // Decrypt the encrypted symmetric key
     val encryptedSecretKeyString = encryptedItem.getString(ENCRYPTED_SECRET_KEY_PROPERTY)
     val encryptedSecretKeyBytes = Base64.decode(encryptedSecretKeyString, Base64.DEFAULT)
@@ -101,10 +114,20 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
 
     // Decrypt the value with the symmetric key
     val secretKeyEntry = KeyStore.SecretKeyEntry(secretKey)
-    return mAESEncryptor.decryptItem(key, encryptedItem, secretKeyEntry, options, authenticationHelper)
+    return mAESEncryptor.decryptItem(
+      key,
+      encryptedItem,
+      secretKeyEntry,
+      options,
+      authenticationHelper,
+    )
   }
 
-  @get:Throws(NoSuchAlgorithmException::class, NoSuchProviderException::class, NoSuchPaddingException::class)
+  @get:Throws(
+    NoSuchAlgorithmException::class,
+    NoSuchProviderException::class,
+    NoSuchPaddingException::class,
+  )
   private val rSACipher: Cipher
     get() = Cipher.getInstance(RSA_CIPHER)
 
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
index e493467..bbea69e 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
@@ -1,5 +1,6 @@
 package expo.modules.securestore.encryptors
 
+import androidx.biometric.BiometricPrompt
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.SecureStoreOptions
 import org.json.JSONException
@@ -9,15 +10,22 @@ import java.security.KeyStore
 
 enum class KeyPurpose {
   ENCRYPT,
-  DECRYPT
+  DECRYPT,
 }
+
 interface KeyBasedEncryptor<E : KeyStore.Entry> {
-  fun getExtendedKeyStoreAlias(options: SecureStoreOptions, requireAuthentication: Boolean): String
+  fun getExtendedKeyStoreAlias(
+    options: SecureStoreOptions,
+    requireAuthentication: Boolean,
+  ): String
 
   fun getKeyStoreAlias(options: SecureStoreOptions): String
 
   @Throws(GeneralSecurityException::class)
-  fun initializeKeyStoreEntry(keyStore: KeyStore, options: SecureStoreOptions): E
+  fun initializeKeyStoreEntry(
+    keyStore: KeyStore,
+    options: SecureStoreOptions,
+  ): E
 
   @Throws(GeneralSecurityException::class, JSONException::class)
   suspend fun createEncryptedItem(
@@ -25,8 +33,9 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     keyStoreEntry: E,
     requireAuthentication: Boolean,
     authenticationPrompt: String,
-    authenticationHelper: AuthenticationHelper
-  ): JSONObject
+    authenticationHelper: AuthenticationHelper,
+    enableCredentialsAlternative: Boolean,
+  ): Pair<JSONObject, BiometricPrompt.AuthenticationResult?>
 
   @Throws(GeneralSecurityException::class, JSONException::class)
   suspend fun decryptItem(
@@ -34,6 +43,6 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     encryptedItem: JSONObject,
     keyStoreEntry: E,
     options: SecureStoreOptions,
-    authenticationHelper: AuthenticationHelper
-  ): String
+    authenticationHelper: AuthenticationHelper,
+  ): Pair<String, BiometricPrompt.AuthenticationResult?>
 }
diff --git a/node_modules/expo-secure-store/build/SecureStore.d.ts b/node_modules/expo-secure-store/build/SecureStore.d.ts
index d5cd157..07dff37 100644
--- a/node_modules/expo-secure-store/build/SecureStore.d.ts
+++ b/node_modules/expo-secure-store/build/SecureStore.d.ts
@@ -1,4 +1,17 @@
 export type KeychainAccessibilityConstant = number;
+
+/**
+ * Authentication type returned by SecureStore after reading item or saving it to the store.
+ */
+export declare const AUTH_TYPE = {
+  UNKNOWN: -1, // Android, haven't encountered it when testing, but according to docs it can be returned
+  NONE: 0, // Android & iOS, returned when authentication fails
+  CREDENTIALS: 1, // Android & iOS, generic type (device passcode or pattern)
+  BIOMETRICS: 2, // Android, generic type (face scan or fingerprint)
+  FACE_ID: 3, // iOS
+  TOUCH_ID: 4, // iOS
+  OPTIC_ID: 5 // iOS, reserved type, not used
+} as const;
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -38,46 +51,70 @@ export declare const WHEN_UNLOCKED: KeychainAccessibilityConstant;
  */
 export declare const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant;
 export type SecureStoreOptions = {
-    /**
-     * - Android: Equivalent of the public/private key pair `Alias`.
-     * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).
-     * > If the item is set with the `keychainService` option, it will be required to later fetch the value.
-     */
-    keychainService?: string;
-    /**
-     * Option responsible for enabling the usage of the user authentication methods available on the device while
-     * accessing data stored in SecureStore.
-     * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))
-     *   (requires API 23).
-     * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).
-     * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`
-     * value used for the others non-authenticated operations.
-     *
-     * This option works slightly differently across platforms: On Android, user authentication is required for all operations.
-     * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).
-     *
-     * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.
-     * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.
-     *
-     */
-    requireAuthentication?: boolean;
-    /**
-     * Custom message displayed to the user while `requireAuthentication` option is turned on.
-     */
-    authenticationPrompt?: string;
-    /**
-     * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.
-     * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).
-     * @default SecureStore.WHEN_UNLOCKED
-     * @platform ios
-     */
-    keychainAccessible?: KeychainAccessibilityConstant;
-    /**
-     * Specifies the access group the stored entry belongs to.
-     * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).
-     * @platform ios
-     */
-    accessGroup?: string;
+  /**
+   * - Android: Equivalent of the public/private key pair `Alias`.
+   * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).
+   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.
+   */
+  keychainService?: string;
+  /**
+   * Option responsible for enabling the usage of the user authentication methods available on the device while
+   * accessing data stored in SecureStore.
+   * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))
+   *   (requires API 23).
+   * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).
+   * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`
+   * value used for the others non-authenticated operations.
+   *
+   * This option works slightly differently across platforms: On Android, user authentication is required for all operations.
+   * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).
+   *
+   * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.
+   * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.
+   *
+   */
+  requireAuthentication?: boolean;
+  /**
+   * Custom message displayed to the user while `requireAuthentication` option is turned on.
+   */
+  authenticationPrompt?: string;
+  /**
+   * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.
+   * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).
+   * @default SecureStore.WHEN_UNLOCKED
+   * @platform ios
+   */
+  keychainAccessible?: KeychainAccessibilityConstant;
+  /**
+   * Specifies the access group the stored entry belongs to.
+   * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).
+   * @platform ios
+   */
+  accessGroup?: string;
+
+  /**
+   * If value already exists, throw an error
+   *
+   * On Android it throws an error before the prompt for authentication.
+   * On iOS it throws an error after authentication.
+   */
+  failOnDuplicate?: boolean;
+
+  /**
+   * On iOS, the system sometimes skips authentication if it has been done recently.
+   * This also applies to actions such as unlocking the screen.
+   * Setting this flag to true will ensure that authentication is always required before accessing the store.
+   * @platform iOS
+   */
+  authOnEveryAction?: boolean;
+
+  /**
+   * On Android, there is often no fallback option if biometrics fail.
+   * Therefore, we may want to allow the user to authenticate using credentials if they prefer to.
+   *
+   * @platform android
+   */
+  enableCredentialsAlternative?: boolean;
 };
 /**
  * Returns whether the SecureStore API is enabled on the current device. This does not check the app
@@ -95,7 +132,10 @@ export declare function isAvailableAsync(): Promise<boolean>;
  *
  * @return A promise that rejects if the value can't be deleted.
  */
-export declare function deleteItemAsync(key: string, options?: SecureStoreOptions): Promise<void>;
+export declare function deleteItemAsync(
+  key: string,
+  options?: SecureStoreOptions,
+): Promise<void>;
 /**
  * Reads the stored value associated with the provided key.
  *
@@ -109,7 +149,10 @@ export declare function deleteItemAsync(key: string, options?: SecureStoreOption
  * > After a key has been invalidated, it becomes impossible to read its value.
  * > This only applies to values stored with `requireAuthentication` set to `true`.
  */
-export declare function getItemAsync(key: string, options?: SecureStoreOptions): Promise<string | null>;
+export declare function getItemAsync(
+  key: string,
+  options?: SecureStoreOptions,
+): Promise<[string | null, AUTH_TYPE]>;
 /**
  * Stores a key–value pair.
  *
@@ -119,7 +162,11 @@ export declare function getItemAsync(key: string, options?: SecureStoreOptions):
  *
  * @return A promise that rejects if value cannot be stored on the device.
  */
-export declare function setItemAsync(key: string, value: string, options?: SecureStoreOptions): Promise<void>;
+export declare function setItemAsync(
+  key: string,
+  value: string,
+  options?: SecureStoreOptions,
+): Promise<AUTH_TYPE>;
 /**
  * Stores a key–value pair synchronously.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.
@@ -129,7 +176,11 @@ export declare function setItemAsync(key: string, value: string, options?: Secur
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export declare function setItem(key: string, value: string, options?: SecureStoreOptions): void;
+export declare function setItem(
+  key: string,
+  value: string,
+  options?: SecureStoreOptions,
+): AUTH_TYPE;
 /**
  * Synchronously reads the stored value associated with the provided key.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`
@@ -140,7 +191,10 @@ export declare function setItem(key: string, value: string, options?: SecureStor
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export declare function getItem(key: string, options?: SecureStoreOptions): string | null;
+export declare function getItem(
+  key: string,
+  options?: SecureStoreOptions,
+): [string | null, AUTH_TYPE];
 /**
  * Checks if the value can be saved with `requireAuthentication` option enabled.
  * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.
diff --git a/node_modules/expo-secure-store/build/SecureStore.js b/node_modules/expo-secure-store/build/SecureStore.js
index 4d87b38..5352a03 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js
+++ b/node_modules/expo-secure-store/build/SecureStore.js
@@ -1,6 +1,19 @@
 import ExpoSecureStore from './ExpoSecureStore';
 import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';
 // @needsAudit
+
+/**
+ * Authentication type returned by SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+    UNKNOWN: -1, // Android, haven't encountered it when testing, but according to docs it can be returned
+    NONE: 0, // Android & iOS, returned when authentication fails
+    CREDENTIALS: 1, // Android & iOS, generic type (device passcode or pattern)
+    BIOMETRICS: 2, // Android, generic type (face scan or fingerprint)
+    FACE_ID: 3, // iOS
+    TOUCH_ID: 4, // iOS
+    OPTIC_ID: 5 // iOS, reserved type, not used
+};
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -102,7 +115,7 @@ export async function setItemAsync(key, value, options = {}) {
     if (!isValidValue(value)) {
         throw new Error(`Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`);
     }
-    await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+    return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }
 /**
  * Stores a key–value pair synchronously.
diff --git a/node_modules/expo-secure-store/build/SecureStore.js.map b/node_modules/expo-secure-store/build/SecureStore.js.map
index 9e8d9f3..4ba6ca0 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js.map
+++ b/node_modules/expo-secure-store/build/SecureStore.js.map
@@ -1 +1 @@
-{"version":3,"file":"SecureStore.js","sourceRoot":"","sources":["../src/SecureStore.ts"],"names":[],"mappings":"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","sourcesContent":["import ExpoSecureStore from './ExpoSecureStore';\nimport { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n *\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK`.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n *\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY`.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - Android: Equivalent of the public/private key pair `Alias`.\n   * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * accessing data stored in SecureStore.\n   * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))\n   *   (requires API 23).\n   * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).\n   * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`\n   * value used for the others non-authenticated operations.\n   *\n   * This option works slightly differently across platforms: On Android, user authentication is required for all operations.\n   * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).\n   *\n   * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.\n   * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.\n   *\n   */\n  requireAuthentication?: boolean;\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string;\n  /**\n   * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.\n   * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).\n   * @default SecureStore.WHEN_UNLOCKED\n   * @platform ios\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n\n  /**\n   * Specifies the access group the stored entry belongs to.\n   * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).\n   * @platform ios\n   */\n  accessGroup?: string;\n};\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils with a `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently, this resolves `true` on Android and iOS only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that rejects if the value can't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  ensureValidKey(key);\n\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Reads the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value. It resolves with `null` if there is no entry\n * for the given key or if the key has been invalidated. It rejects if an error occurs while retrieving the value.\n *\n * > Keys are invalidated by the system when biometrics change, such as adding a new fingerprint or changing the face profile used for face recognition.\n * > After a key has been invalidated, it becomes impossible to read its value.\n * > This only applies to values stored with `requireAuthentication` set to `true`.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Stores a key–value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that rejects if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\n/**\n * Stores a key–value pair synchronously.\n * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n */\nexport function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n\n  return ExpoSecureStore.setValueWithKeySync(value, key, options);\n}\n\n/**\n * Synchronously reads the stored value associated with the provided key.\n * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`\n * > option set to `true` until the user authenticates.\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return Previously stored value. It resolves with `null` if there is no entry\n * for the given key or if the key has been invalidated.\n */\nexport function getItem(key: string, options: SecureStoreOptions = {}): string | null {\n  ensureValidKey(key);\n  return ExpoSecureStore.getValueWithKeySync(key, options);\n}\n\n/**\n * Checks if the value can be saved with `requireAuthentication` option enabled.\n * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.\n * @platform android\n * @platform ios\n */\nexport function canUseBiometricAuthentication(): boolean {\n  return ExpoSecureStore.canUseBiometricAuthentication();\n}\n\nfunction ensureValidKey(key: string) {\n  if (!isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (byteCountOverLimit(value, VALUE_BYTES_LIMIT)) {\n    console.warn(\n      `Value being stored in SecureStore is larger than ${VALUE_BYTES_LIMIT} bytes and it may not be stored successfully. In a future SDK version, this call may throw an error.`\n    );\n  }\n  return true;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SecureStore.js","sourceRoot":"","sources":["../src/SecureStore.ts"],"names":[],"mappings":"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","sourcesContent":["import ExpoSecureStore from './ExpoSecureStore';\nimport { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n *\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK`.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n *\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY`.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - Android: Equivalent of the public/private key pair `Alias`.\n   * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * accessing data stored in SecureStore.\n   * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))\n   *   (requires API 23).\n   * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).\n   * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`\n   * value used for the others non-authenticated operations.\n   *\n   * This option works slightly differently across platforms: On Android, user authentication is required for all operations.\n   * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).\n   *\n   * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.\n   * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.\n   *\n   */\n  requireAuthentication?: boolean;\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string;\n  /**\n   * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.\n   * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).\n   * @default SecureStore.WHEN_UNLOCKED\n   * @platform ios\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n\n  /**\n   * Specifies the access group the stored entry belongs to.\n   * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).\n   * @platform ios\n   */\n  accessGroup?: string;\n};\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils with a `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently, this resolves `true` on Android and iOS only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that rejects if the value can't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  ensureValidKey(key);\n\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Reads the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value. It resolves with `null` if there is no entry\n * for the given key or if the key has been invalidated. It rejects if an error occurs while retrieving the value.\n *\n * > Keys are invalidated by the system when biometrics change, such as adding a new fingerprint or changing the face profile used for face recognition.\n * > After a key has been invalidated, it becomes impossible to read its value.\n * > This only applies to values stored with `requireAuthentication` set to `true`.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Stores a key–value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that rejects if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n\n return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\n/**\n * Stores a key–value pair synchronously.\n * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n */\nexport function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n\n  return ExpoSecureStore.setValueWithKeySync(value, key, options);\n}\n\n/**\n * Synchronously reads the stored value associated with the provided key.\n * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`\n * > option set to `true` until the user authenticates.\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return Previously stored value. It resolves with `null` if there is no entry\n * for the given key or if the key has been invalidated.\n */\nexport function getItem(key: string, options: SecureStoreOptions = {}): string | null {\n  ensureValidKey(key);\n  return ExpoSecureStore.getValueWithKeySync(key, options);\n}\n\n/**\n * Checks if the value can be saved with `requireAuthentication` option enabled.\n * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.\n * @platform android\n * @platform ios\n */\nexport function canUseBiometricAuthentication(): boolean {\n  return ExpoSecureStore.canUseBiometricAuthentication();\n}\n\nfunction ensureValidKey(key: string) {\n  if (!isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (byteCountOverLimit(value, VALUE_BYTES_LIMIT)) {\n    console.warn(\n      `Value being stored in SecureStore is larger than ${VALUE_BYTES_LIMIT} bytes and it may not be stored successfully. In a future SDK version, this call may throw an error.`\n    );\n  }\n  return true;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/expo-secure-store/ios/SecureStoreModule.swift b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
index 439b08d..d89d627 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreModule.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
@@ -1,83 +1,209 @@
 import ExpoModulesCore
+import Security
+
 #if !os(tvOS)
 import LocalAuthentication
 #endif
-import Security
+
+@available(iOS 11.0, *)
+public enum AuthType: Int, @unchecked Sendable {
+  /// The device does not support biometry.
+  @available(iOS 11.2, *)
+  case none = 0
+  
+  case credentials = 1
+  
+  /// The device supports Face ID.
+  case faceID = 3
+  
+  /// The device supports Touch ID.
+  case touchID = 4
+  
+  /// The device supports Optic ID
+  @available(iOS 17.0, *)
+  case opticID = 5
+}
+
+struct RuntimeError: LocalizedError {
+  let description: String
+  
+  init(_ description: String) {
+    self.description = description
+  }
+  
+  var errorDescription: String? {
+    description
+  }
+}
 
 public final class SecureStoreModule: Module {
   public func definition() -> ModuleDefinition {
     Name("ExpoSecureStore")
     
     Constants([
-      "AFTER_FIRST_UNLOCK": SecureStoreAccessible.afterFirstUnlock.rawValue,
-      "AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY": SecureStoreAccessible.afterFirstUnlockThisDeviceOnly.rawValue,
+      "AFTER_FIRST_UNLOCK": SecureStoreAccessible.afterFirstUnlock
+        .rawValue,
+      "AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY": SecureStoreAccessible
+        .afterFirstUnlockThisDeviceOnly.rawValue,
       "ALWAYS": SecureStoreAccessible.always.rawValue,
-      "WHEN_PASSCODE_SET_THIS_DEVICE_ONLY": SecureStoreAccessible.whenPasscodeSetThisDeviceOnly.rawValue,
-      "ALWAYS_THIS_DEVICE_ONLY": SecureStoreAccessible.alwaysThisDeviceOnly.rawValue,
+      "WHEN_PASSCODE_SET_THIS_DEVICE_ONLY": SecureStoreAccessible
+        .whenPasscodeSetThisDeviceOnly.rawValue,
+      "ALWAYS_THIS_DEVICE_ONLY": SecureStoreAccessible
+        .alwaysThisDeviceOnly.rawValue,
       "WHEN_UNLOCKED": SecureStoreAccessible.whenUnlocked.rawValue,
-      "WHEN_UNLOCKED_THIS_DEVICE_ONLY": SecureStoreAccessible.whenUnlockedThisDeviceOnly.rawValue
+      "WHEN_UNLOCKED_THIS_DEVICE_ONLY": SecureStoreAccessible
+        .whenUnlockedThisDeviceOnly.rawValue,
     ])
     
-    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    AsyncFunction("getValueWithKeyAsync") {
+      (key: String, options: SecureStoreOptions) -> [Any] in
+      let returnValue = try get(with: key, options: options)
+      
+      if options.requireAuthentication && options.authOnEveryAction {
+        try await askForAuth(
+          prompt: options.authenticationPrompt
+          ?? "Authentication required"
+        )
+      }
+      
+      return [returnValue as Any, getAuthType().rawValue]
     }
     
-    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    Function("getValueWithKeySync") {
+      (key: String, options: SecureStoreOptions) -> [Any] in
+      let returnValue = try get(with: key, options: options)
+      return [returnValue as Any, getAuthType().rawValue]
     }
     
-    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) -> Bool in
+    AsyncFunction("setValueWithKeyAsync") {
+      (value: String, key: String, options: SecureStoreOptions)
+      -> Int in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }
       
-      return try set(value: value, with: key, options: options)
+      if options.requireAuthentication && options.authOnEveryAction {
+        try await askForAuth(
+          prompt: options.authenticationPrompt
+          ?? "Authentication required"
+        )
+      }
+      
+      let result = try set(value: value, with: key, options: options)
+      
+      if !result {
+        return AuthType.none.rawValue
+      }
+      
+      return getAuthType().rawValue
     }
     
-    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) -> Bool in
+    Function("setValueWithKeySync") {
+      (value: String, key: String, options: SecureStoreOptions)
+      -> Int in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }
       
-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+      
+      if !result {
+        return AuthType.none.rawValue
+      }
+      
+      return getAuthType().rawValue
     }
     
-    AsyncFunction("deleteValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
-      let noAuthSearchDictionary = query(with: key, options: options, requireAuthentication: false)
-      let authSearchDictionary = query(with: key, options: options, requireAuthentication: true)
-      let legacySearchDictionary = query(with: key, options: options)
+    AsyncFunction("deleteValueWithKeyAsync") {
+      (key: String, options: SecureStoreOptions) in
+      let noAuthSearchDictionary = try query(
+        with: key,
+        options: options,
+        requireAuthentication: false
+      )
+      let authSearchDictionary = try query(
+        with: key,
+        options: options,
+        requireAuthentication: true
+      )
+      let legacySearchDictionary = try query(with: key, options: options)
       
       SecItemDelete(legacySearchDictionary as CFDictionary)
       SecItemDelete(authSearchDictionary as CFDictionary)
       SecItemDelete(noAuthSearchDictionary as CFDictionary)
     }
     
-    Function("canUseBiometricAuthentication") {() -> Bool in
-      #if os(tvOS)
+    Function("canUseBiometricAuthentication") { () -> Bool in
+      return areBiometricsEnabled()
+    }
+  }
+  
+  private func areBiometricsEnabled() -> Bool {
+#if os(tvOS)
+    return false
+#else
+    let context = LAContext()
+    var error: NSError?
+    let isBiometricsSupported: Bool = context.canEvaluatePolicy(
+      LAPolicy.deviceOwnerAuthenticationWithBiometrics,
+      error: &error
+    )
+    
+    if error != nil {
       return false
-      #else
-      let context = LAContext()
-      var error: NSError?
-      let isBiometricsSupported: Bool = context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &error)
+    }
+    return isBiometricsSupported
+#endif
+  }
+  
+  private func getAuthType() -> AuthType {
+    if !areBiometricsEnabled() {
+      return AuthType.credentials
+    }
+    
+    let biometryType = LAContext().biometryType
     
-      if error != nil {
-        return false
+    if biometryType == LABiometryType.none {
+      return AuthType.credentials
+    }
+    
+    if biometryType == LABiometryType.faceID {
+      return AuthType.faceID
+    }
+    
+    if biometryType == LABiometryType.touchID {
+      return AuthType.touchID
+    }
+    
+    if #available(iOS 17.0, *) {
+      if biometryType == LABiometryType.opticID {
+        return AuthType.opticID
       }
-      return isBiometricsSupported
-      #endif
     }
+    
+    return AuthType.credentials
   }
   
-  private func get(with key: String, options: SecureStoreOptions) throws -> String? {
+  private func get(with key: String, options: SecureStoreOptions) throws
+  -> String?
+  {
     guard let key = validate(for: key) else {
       throw InvalidKeyException()
     }
     
-    if let unauthenticatedItem = try searchKeyChain(with: key, options: options, requireAuthentication: false) {
+    if let unauthenticatedItem = try searchKeyChain(
+      with: key,
+      options: options,
+      requireAuthentication: false
+    ) {
       return String(data: unauthenticatedItem, encoding: .utf8)
     }
     
-    if let authenticatedItem = try searchKeyChain(with: key, options: options, requireAuthentication: true) {
+    if let authenticatedItem = try searchKeyChain(
+      with: key,
+      options: options,
+      requireAuthentication: true
+    ) {
       return String(data: authenticatedItem, encoding: .utf8)
     }
     
@@ -88,8 +214,42 @@ public final class SecureStoreModule: Module {
     return nil
   }
   
-  private func set(value: String, with key: String, options: SecureStoreOptions) throws -> Bool {
-    var setItemQuery = query(with: key, options: options, requireAuthentication: options.requireAuthentication)
+  private func getAccessControl(accessibility: CFString) throws
+  -> SecAccessControl
+  {
+    guard
+      Bundle.main.infoDictionary?["NSFaceIDUsageDescription"] as? String
+        != nil
+    else {
+      throw MissingPlistKeyException()
+    }
+    
+    var error: Unmanaged<CFError>? = nil
+    guard
+      let accessOptions = SecAccessControlCreateWithFlags(
+        kCFAllocatorDefault,
+        accessibility,
+        .userPresence,
+        &error
+      )
+    else {
+      let errorCode = error.map { CFErrorGetCode($0.takeRetainedValue()) }
+      throw SecAccessControlError(errorCode)
+    }
+    
+    return accessOptions
+  }
+  
+  private func set(
+    value: String,
+    with key: String,
+    options: SecureStoreOptions
+  ) throws -> Bool {
+    var setItemQuery = try query(
+      with: key,
+      options: options,
+      requireAuthentication: options.requireAuthentication
+    )
     
     let valueData = value.data(using: .utf8)
     setItemQuery[kSecValueData as String] = valueData
@@ -98,17 +258,6 @@ public final class SecureStoreModule: Module {
     
     if !options.requireAuthentication {
       setItemQuery[kSecAttrAccessible as String] = accessibility
-    } else {
-      guard let _ = Bundle.main.infoDictionary?["NSFaceIDUsageDescription"] as? String else {
-        throw MissingPlistKeyException()
-      }
-
-      var error: Unmanaged<CFError>? = nil
-      guard let accessOptions = SecAccessControlCreateWithFlags(kCFAllocatorDefault, accessibility, .biometryCurrentSet, &error) else {
-        let errorCode = error.map { CFErrorGetCode($0.takeRetainedValue()) }
-        throw SecAccessControlError(errorCode)
-      }
-      setItemQuery[kSecAttrAccessControl as String] = accessOptions
     }
     
     let status = SecItemAdd(setItemQuery as CFDictionary, nil)
@@ -116,27 +265,45 @@ public final class SecureStoreModule: Module {
     switch status {
     case errSecSuccess:
       // On success we want to remove the other key alias and legacy key (if they exist) to avoid conflicts during reads
-      SecItemDelete(query(with: key, options: options) as CFDictionary)
-      SecItemDelete(query(with: key, options: options, requireAuthentication: !options.requireAuthentication) as CFDictionary)
+      SecItemDelete(
+        try query(with: key, options: options) as CFDictionary
+      )
+      SecItemDelete(
+        try query(
+          with: key,
+          options: options,
+          requireAuthentication: !options.requireAuthentication
+        ) as CFDictionary
+      )
       return true
     case errSecDuplicateItem:
+      if options.failOnDuplicate {
+        throw RuntimeError("Key already exists")
+      }
       return try update(value: value, with: key, options: options)
     default:
       throw KeyChainException(status)
     }
   }
   
-  private func update(value: String, with key: String, options: SecureStoreOptions) throws -> Bool {
-    var query = query(with: key, options: options, requireAuthentication: options.requireAuthentication)
+  private func update(
+    value: String,
+    with key: String,
+    options: SecureStoreOptions
+  ) throws -> Bool {
+    let query = try query(
+      with: key,
+      options: options,
+      requireAuthentication: options.requireAuthentication
+    )
     
     let valueData = value.data(using: .utf8)
     let updateDictionary = [kSecValueData as String: valueData]
     
-    if let authPrompt = options.authenticationPrompt {
-      query[kSecUseOperationPrompt as String] = authPrompt
-    }
-
-    let status = SecItemUpdate(query as CFDictionary, updateDictionary as CFDictionary)
+    let status = SecItemUpdate(
+      query as CFDictionary,
+      updateDictionary as CFDictionary
+    )
     
     if status == errSecSuccess {
       return true
@@ -145,16 +312,44 @@ public final class SecureStoreModule: Module {
     }
   }
   
-  private func searchKeyChain(with key: String, options: SecureStoreOptions, requireAuthentication: Bool? = nil) throws -> Data? {
-    var query = query(with: key, options: options, requireAuthentication: requireAuthentication)
+  private func askForAuth(prompt: String) async throws {
+    let context = LAContext()
+    context.localizedReason = prompt
+    var error: NSError?
+    let isAuthenticationSupported: Bool = context.canEvaluatePolicy(
+      LAPolicy.deviceOwnerAuthentication,
+      error: &error
+    )
+    if error != nil {
+      throw error ?? RuntimeError("No authentication method available")
+    }
+    if !isAuthenticationSupported {
+      throw RuntimeError("No authentication method available")
+    }
+    let result = try await context.evaluatePolicy(
+      LAPolicy.deviceOwnerAuthentication,
+      localizedReason: context.localizedReason
+    )
+    
+    if !result {
+      throw RuntimeError("Unable to authenticate")
+    }
+  }
+  
+  private func searchKeyChain(
+    with key: String,
+    options: SecureStoreOptions,
+    requireAuthentication: Bool? = nil
+  ) throws -> Data? {
+    var query = try query(
+      with: key,
+      options: options,
+      requireAuthentication: requireAuthentication
+    )
     
     query[kSecMatchLimit as String] = kSecMatchLimitOne
     query[kSecReturnData as String] = kCFBooleanTrue
     
-    if let authPrompt = options.authenticationPrompt {
-      query[kSecUseOperationPrompt as String] = authPrompt
-    }
-
     var item: CFTypeRef?
     let status = SecItemCopyMatching(query as CFDictionary, &item)
     
@@ -171,21 +366,32 @@ public final class SecureStoreModule: Module {
     }
   }
   
-  private func query(with key: String, options: SecureStoreOptions, requireAuthentication: Bool? = nil) -> [String: Any] {
+  private func query(
+    with key: String,
+    options: SecureStoreOptions,
+    requireAuthentication: Bool? = nil
+  ) throws -> [String: Any] {
     var service = options.keychainService ?? "app"
     if let requireAuthentication {
       service.append(":\(requireAuthentication ? "auth" : "no-auth")")
     }
     
     let encodedKey = Data(key.utf8)
+    let accessibility = attributeWith(options: options)
     
     var query: [String: Any] = [
       kSecClass as String: kSecClassGenericPassword,
       kSecAttrService as String: service,
       kSecAttrGeneric as String: encodedKey,
-      kSecAttrAccount as String: encodedKey
+      kSecAttrAccount as String: encodedKey,
     ]
     
+    if options.requireAuthentication {
+      query[kSecAttrAccessControl as String] = try getAccessControl(
+        accessibility: accessibility
+      )
+    }
+    
     if let accessGroup = options.accessGroup {
       query[kSecAttrAccessGroup as String] = accessGroup
     }
diff --git a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
index 7e3fa4d..27d859d 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
@@ -15,4 +15,10 @@ internal struct SecureStoreOptions: Record {
   
   @Field
   var accessGroup: String?
+  
+  @Field
+  var failOnDuplicate: Bool = false
+  
+  @Field
+  var authOnEveryAction: Bool = false
 }
diff --git a/node_modules/expo-secure-store/src/SecureStore.ts b/node_modules/expo-secure-store/src/SecureStore.ts
index ee43e04..2c6aa8f 100644
--- a/node_modules/expo-secure-store/src/SecureStore.ts
+++ b/node_modules/expo-secure-store/src/SecureStore.ts
@@ -1,15 +1,26 @@
-import ExpoSecureStore from './ExpoSecureStore';
-import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';
+import ExpoSecureStore from "./ExpoSecureStore";
+import { byteCountOverLimit, VALUE_BYTES_LIMIT } from "./byteCounter";
 
 export type KeychainAccessibilityConstant = number;
 
+export const AUTH_TYPE = {
+  UNKNOWN: -1, // Android, haven't encountered it when testing, but according to docs it can be returned
+  NONE: 0, // Android & iOS, returned when authentication fails
+  CREDENTIALS: 1, // Android & iOS, generic type (device passcode or pattern)
+  BIOMETRICS: 2, // Android, generic type (face scan or fingerprint)
+  FACE_ID: 3, // iOS
+  TOUCH_ID: 4, // iOS
+  OPTIC_ID: 5 // iOS, reserved type, not used
+} as const;
+
 // @needsAudit
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
  * is locked.
  */
-export const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;
+export const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant =
+  ExpoSecureStore.AFTER_FIRST_UNLOCK;
 
 // @needsAudit
 /**
@@ -49,7 +60,8 @@ export const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =
 /**
  * The data in the keychain item can be accessed only while the device is unlocked by the user.
  */
-export const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;
+export const WHEN_UNLOCKED: KeychainAccessibilityConstant =
+  ExpoSecureStore.WHEN_UNLOCKED;
 
 // @needsAudit
 /**
@@ -102,6 +114,31 @@ export type SecureStoreOptions = {
    * @platform ios
    */
   accessGroup?: string;
+
+  /**
+   * If value already exists, throw an error
+   *
+   * On Android it throws an error before the prompt for authentication.
+   * On iOS it throws an error after authentication.
+   */
+  failOnDuplicate?: boolean;
+
+  /**
+   * On iOS, the system sometimes skips authentication if it has been done recently.
+   * This also applies to actions such as unlocking the screen.
+   * Setting this flag to true will ensure that authentication is always required before accessing the store.
+   *
+   * @platform ios
+   */
+  authOnEveryAction?: boolean;
+
+  /**
+   * On Android, there is often no fallback option if biometrics fail.
+   * Therefore, we may want to allow the user to authenticate using credentials if they prefer to.
+   *
+   * @platform android
+   */
+  enableCredentialsAlternative?: boolean;
 };
 
 // @needsAudit
@@ -127,7 +164,7 @@ export async function isAvailableAsync(): Promise<boolean> {
  */
 export async function deleteItemAsync(
   key: string,
-  options: SecureStoreOptions = {}
+  options: SecureStoreOptions = {},
 ): Promise<void> {
   ensureValidKey(key);
 
@@ -150,8 +187,8 @@ export async function deleteItemAsync(
  */
 export async function getItemAsync(
   key: string,
-  options: SecureStoreOptions = {}
-): Promise<string | null> {
+  options: SecureStoreOptions = {},
+): Promise<[string | null, AUTH_TYPE]> {
   ensureValidKey(key);
   return await ExpoSecureStore.getValueWithKeyAsync(key, options);
 }
@@ -169,16 +206,16 @@ export async function getItemAsync(
 export async function setItemAsync(
   key: string,
   value: string,
-  options: SecureStoreOptions = {}
-): Promise<void> {
+  options: SecureStoreOptions = {},
+): Promise<AUTH_TYPE> {
   ensureValidKey(key);
   if (!isValidValue(value)) {
     throw new Error(
-      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`
+      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`,
     );
   }
 
-  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+  return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }
 
 /**
@@ -190,11 +227,15 @@ export async function setItemAsync(
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {
+export function setItem(
+  key: string,
+  value: string,
+  options: SecureStoreOptions = {},
+): AUTH_TYPE {
   ensureValidKey(key);
   if (!isValidValue(value)) {
     throw new Error(
-      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`
+      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`,
     );
   }
 
@@ -211,7 +252,10 @@ export function setItem(key: string, value: string, options: SecureStoreOptions
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export function getItem(key: string, options: SecureStoreOptions = {}): string | null {
+export function getItem(
+  key: string,
+  options: SecureStoreOptions = {},
+): [string | null, AUTH_TYPE] {
   ensureValidKey(key);
   return ExpoSecureStore.getValueWithKeySync(key, options);
 }
@@ -229,22 +273,22 @@ export function canUseBiometricAuthentication(): boolean {
 function ensureValidKey(key: string) {
   if (!isValidKey(key)) {
     throw new Error(
-      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, ".", "-", and "_".`
+      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, ".", "-", and "_".`,
     );
   }
 }
 
 function isValidKey(key: string) {
-  return typeof key === 'string' && /^[\w.-]+$/.test(key);
+  return typeof key === "string" && /^[\w.-]+$/.test(key);
 }
 
 function isValidValue(value: string) {
-  if (typeof value !== 'string') {
+  if (typeof value !== "string") {
     return false;
   }
   if (byteCountOverLimit(value, VALUE_BYTES_LIMIT)) {
     console.warn(
-      `Value being stored in SecureStore is larger than ${VALUE_BYTES_LIMIT} bytes and it may not be stored successfully. In a future SDK version, this call may throw an error.`
+      `Value being stored in SecureStore is larger than ${VALUE_BYTES_LIMIT} bytes and it may not be stored successfully. In a future SDK version, this call may throw an error.`,
     );
   }
   return true;
